import "./chunk.ZGTBNHQT.js";
import {
  applyStyles_default,
  createPopper2 as createPopper
} from "./chunk.2EPY5I3Y.js";
import {
  require_react_dom
} from "./chunk.NJLDE6UR.js";
import "./chunk.KM4KWRBF.js";
import {
  __toModule
} from "./chunk.5JD2HCIV.js";
import "./chunk.FNFVRXQK.js";
import {
  require_react
} from "./chunk.BD4KNU7W.js";
import "./chunk.MXG56MB2.js";
import "./chunk.5OSL2VXB.js";
import {
  __name
} from "./chunk.C4F35LU4.js";

// ../.yarn/cache/tippy.js-npm-6.3.1-e96c0f7147-e4194c4242.zip/node_modules/tippy.js/headless/dist/tippy-headless.esm.js
var CONTENT_CLASS = "tippy-content";
var BACKDROP_CLASS = "tippy-backdrop";
var ARROW_CLASS = "tippy-arrow";
var SVG_ARROW_CLASS = "tippy-svg-arrow";
var TOUCH_OPTIONS = {
  passive: true,
  capture: true
};
function hasOwnProperty(obj, key) {
  return {}.hasOwnProperty.call(obj, key);
}
__name(hasOwnProperty, "hasOwnProperty");
function getValueAtIndexOrReturn(value, index, defaultValue) {
  if (Array.isArray(value)) {
    var v = value[index];
    return v == null ? Array.isArray(defaultValue) ? defaultValue[index] : defaultValue : v;
  }
  return value;
}
__name(getValueAtIndexOrReturn, "getValueAtIndexOrReturn");
function isType(value, type) {
  var str = {}.toString.call(value);
  return str.indexOf("[object") === 0 && str.indexOf(type + "]") > -1;
}
__name(isType, "isType");
function invokeWithArgsOrReturn(value, args) {
  return typeof value === "function" ? value.apply(void 0, args) : value;
}
__name(invokeWithArgsOrReturn, "invokeWithArgsOrReturn");
function debounce(fn2, ms) {
  if (ms === 0) {
    return fn2;
  }
  var timeout;
  return function(arg) {
    clearTimeout(timeout);
    timeout = setTimeout(function() {
      fn2(arg);
    }, ms);
  };
}
__name(debounce, "debounce");
function removeProperties(obj, keys) {
  var clone = Object.assign({}, obj);
  keys.forEach(function(key) {
    delete clone[key];
  });
  return clone;
}
__name(removeProperties, "removeProperties");
function splitBySpaces(value) {
  return value.split(/\s+/).filter(Boolean);
}
__name(splitBySpaces, "splitBySpaces");
function normalizeToArray(value) {
  return [].concat(value);
}
__name(normalizeToArray, "normalizeToArray");
function pushIfUnique(arr, value) {
  if (arr.indexOf(value) === -1) {
    arr.push(value);
  }
}
__name(pushIfUnique, "pushIfUnique");
function unique(arr) {
  return arr.filter(function(item, index) {
    return arr.indexOf(item) === index;
  });
}
__name(unique, "unique");
function getBasePlacement(placement) {
  return placement.split("-")[0];
}
__name(getBasePlacement, "getBasePlacement");
function arrayFrom(value) {
  return [].slice.call(value);
}
__name(arrayFrom, "arrayFrom");
function removeUndefinedProps(obj) {
  return Object.keys(obj).reduce(function(acc, key) {
    if (obj[key] !== void 0) {
      acc[key] = obj[key];
    }
    return acc;
  }, {});
}
__name(removeUndefinedProps, "removeUndefinedProps");
function div() {
  return document.createElement("div");
}
__name(div, "div");
function isElement(value) {
  return ["Element", "Fragment"].some(function(type) {
    return isType(value, type);
  });
}
__name(isElement, "isElement");
function isNodeList(value) {
  return isType(value, "NodeList");
}
__name(isNodeList, "isNodeList");
function isMouseEvent(value) {
  return isType(value, "MouseEvent");
}
__name(isMouseEvent, "isMouseEvent");
function isReferenceElement(value) {
  return !!(value && value._tippy && value._tippy.reference === value);
}
__name(isReferenceElement, "isReferenceElement");
function getArrayOfElements(value) {
  if (isElement(value)) {
    return [value];
  }
  if (isNodeList(value)) {
    return arrayFrom(value);
  }
  if (Array.isArray(value)) {
    return value;
  }
  return arrayFrom(document.querySelectorAll(value));
}
__name(getArrayOfElements, "getArrayOfElements");
function setTransitionDuration(els, value) {
  els.forEach(function(el) {
    if (el) {
      el.style.transitionDuration = value + "ms";
    }
  });
}
__name(setTransitionDuration, "setTransitionDuration");
function setVisibilityState(els, state) {
  els.forEach(function(el) {
    if (el) {
      el.setAttribute("data-state", state);
    }
  });
}
__name(setVisibilityState, "setVisibilityState");
function getOwnerDocument(elementOrElements) {
  var _element$ownerDocumen;
  var _normalizeToArray = normalizeToArray(elementOrElements), element = _normalizeToArray[0];
  return (element == null ? void 0 : (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body) ? element.ownerDocument : document;
}
__name(getOwnerDocument, "getOwnerDocument");
function isCursorOutsideInteractiveBorder(popperTreeData, event) {
  var clientX = event.clientX, clientY = event.clientY;
  return popperTreeData.every(function(_ref) {
    var popperRect = _ref.popperRect, popperState = _ref.popperState, props = _ref.props;
    var interactiveBorder = props.interactiveBorder;
    var basePlacement = getBasePlacement(popperState.placement);
    var offsetData = popperState.modifiersData.offset;
    if (!offsetData) {
      return true;
    }
    var topDistance = basePlacement === "bottom" ? offsetData.top.y : 0;
    var bottomDistance = basePlacement === "top" ? offsetData.bottom.y : 0;
    var leftDistance = basePlacement === "right" ? offsetData.left.x : 0;
    var rightDistance = basePlacement === "left" ? offsetData.right.x : 0;
    var exceedsTop = popperRect.top - clientY + topDistance > interactiveBorder;
    var exceedsBottom = clientY - popperRect.bottom - bottomDistance > interactiveBorder;
    var exceedsLeft = popperRect.left - clientX + leftDistance > interactiveBorder;
    var exceedsRight = clientX - popperRect.right - rightDistance > interactiveBorder;
    return exceedsTop || exceedsBottom || exceedsLeft || exceedsRight;
  });
}
__name(isCursorOutsideInteractiveBorder, "isCursorOutsideInteractiveBorder");
function updateTransitionEndListener(box, action, listener) {
  var method = action + "EventListener";
  ["transitionend", "webkitTransitionEnd"].forEach(function(event) {
    box[method](event, listener);
  });
}
__name(updateTransitionEndListener, "updateTransitionEndListener");
var currentInput = {
  isTouch: false
};
var lastMouseMoveTime = 0;
function onDocumentTouchStart() {
  if (currentInput.isTouch) {
    return;
  }
  currentInput.isTouch = true;
  if (window.performance) {
    document.addEventListener("mousemove", onDocumentMouseMove);
  }
}
__name(onDocumentTouchStart, "onDocumentTouchStart");
function onDocumentMouseMove() {
  var now = performance.now();
  if (now - lastMouseMoveTime < 20) {
    currentInput.isTouch = false;
    document.removeEventListener("mousemove", onDocumentMouseMove);
  }
  lastMouseMoveTime = now;
}
__name(onDocumentMouseMove, "onDocumentMouseMove");
function onWindowBlur() {
  var activeElement = document.activeElement;
  if (isReferenceElement(activeElement)) {
    var instance = activeElement._tippy;
    if (activeElement.blur && !instance.state.isVisible) {
      activeElement.blur();
    }
  }
}
__name(onWindowBlur, "onWindowBlur");
function bindGlobalEventListeners() {
  document.addEventListener("touchstart", onDocumentTouchStart, TOUCH_OPTIONS);
  window.addEventListener("blur", onWindowBlur);
}
__name(bindGlobalEventListeners, "bindGlobalEventListeners");
var isBrowser = typeof window !== "undefined" && typeof document !== "undefined";
var ua = isBrowser ? navigator.userAgent : "";
var isIE = /MSIE |Trident\//.test(ua);
function createMemoryLeakWarning(method) {
  var txt = method === "destroy" ? "n already-" : " ";
  return [method + "() was called on a" + txt + "destroyed instance. This is a no-op but", "indicates a potential memory leak."].join(" ");
}
__name(createMemoryLeakWarning, "createMemoryLeakWarning");
function clean(value) {
  var spacesAndTabs = /[ \t]{2,}/g;
  var lineStartWithSpaces = /^[ \t]*/gm;
  return value.replace(spacesAndTabs, " ").replace(lineStartWithSpaces, "").trim();
}
__name(clean, "clean");
function getDevMessage(message) {
  return clean("\n  %ctippy.js\n\n  %c" + clean(message) + "\n\n  %c\u{1F477}\u200D This is a development-only message. It will be removed in production.\n  ");
}
__name(getDevMessage, "getDevMessage");
function getFormattedMessage(message) {
  return [
    getDevMessage(message),
    "color: #00C584; font-size: 1.3em; font-weight: bold;",
    "line-height: 1.5",
    "color: #a6a095;"
  ];
}
__name(getFormattedMessage, "getFormattedMessage");
var visitedMessages;
if (true) {
  resetVisitedMessages();
}
function resetVisitedMessages() {
  visitedMessages = new Set();
}
__name(resetVisitedMessages, "resetVisitedMessages");
function warnWhen(condition, message) {
  if (condition && !visitedMessages.has(message)) {
    var _console;
    visitedMessages.add(message);
    (_console = console).warn.apply(_console, getFormattedMessage(message));
  }
}
__name(warnWhen, "warnWhen");
function errorWhen(condition, message) {
  if (condition && !visitedMessages.has(message)) {
    var _console2;
    visitedMessages.add(message);
    (_console2 = console).error.apply(_console2, getFormattedMessage(message));
  }
}
__name(errorWhen, "errorWhen");
function validateTargets(targets) {
  var didPassFalsyValue = !targets;
  var didPassPlainObject = Object.prototype.toString.call(targets) === "[object Object]" && !targets.addEventListener;
  errorWhen(didPassFalsyValue, ["tippy() was passed", "`" + String(targets) + "`", "as its targets (first) argument. Valid types are: String, Element,", "Element[], or NodeList."].join(" "));
  errorWhen(didPassPlainObject, ["tippy() was passed a plain object which is not supported as an argument", "for virtual positioning. Use props.getReferenceClientRect instead."].join(" "));
}
__name(validateTargets, "validateTargets");
var pluginProps = {
  animateFill: false,
  followCursor: false,
  inlinePositioning: false,
  sticky: false
};
var renderProps = {
  allowHTML: false,
  animation: "fade",
  arrow: true,
  content: "",
  inertia: false,
  maxWidth: 350,
  role: "tooltip",
  theme: "",
  zIndex: 9999
};
var defaultProps = Object.assign({
  appendTo: /* @__PURE__ */ __name(function appendTo() {
    return document.body;
  }, "appendTo"),
  aria: {
    content: "auto",
    expanded: "auto"
  },
  delay: 0,
  duration: [300, 250],
  getReferenceClientRect: null,
  hideOnClick: true,
  ignoreAttributes: false,
  interactive: false,
  interactiveBorder: 2,
  interactiveDebounce: 0,
  moveTransition: "",
  offset: [0, 10],
  onAfterUpdate: /* @__PURE__ */ __name(function onAfterUpdate() {
  }, "onAfterUpdate"),
  onBeforeUpdate: /* @__PURE__ */ __name(function onBeforeUpdate() {
  }, "onBeforeUpdate"),
  onCreate: /* @__PURE__ */ __name(function onCreate() {
  }, "onCreate"),
  onDestroy: /* @__PURE__ */ __name(function onDestroy() {
  }, "onDestroy"),
  onHidden: /* @__PURE__ */ __name(function onHidden() {
  }, "onHidden"),
  onHide: /* @__PURE__ */ __name(function onHide() {
  }, "onHide"),
  onMount: /* @__PURE__ */ __name(function onMount() {
  }, "onMount"),
  onShow: /* @__PURE__ */ __name(function onShow() {
  }, "onShow"),
  onShown: /* @__PURE__ */ __name(function onShown() {
  }, "onShown"),
  onTrigger: /* @__PURE__ */ __name(function onTrigger() {
  }, "onTrigger"),
  onUntrigger: /* @__PURE__ */ __name(function onUntrigger() {
  }, "onUntrigger"),
  onClickOutside: /* @__PURE__ */ __name(function onClickOutside() {
  }, "onClickOutside"),
  placement: "top",
  plugins: [],
  popperOptions: {},
  render: null,
  showOnCreate: false,
  touch: true,
  trigger: "mouseenter focus",
  triggerTarget: null
}, pluginProps, {}, renderProps);
var defaultKeys = Object.keys(defaultProps);
var setDefaultProps = /* @__PURE__ */ __name(function setDefaultProps2(partialProps) {
  if (true) {
    validateProps(partialProps, []);
  }
  var keys = Object.keys(partialProps);
  keys.forEach(function(key) {
    defaultProps[key] = partialProps[key];
  });
}, "setDefaultProps");
function getExtendedPassedProps(passedProps) {
  var plugins = passedProps.plugins || [];
  var pluginProps2 = plugins.reduce(function(acc, plugin) {
    var name = plugin.name, defaultValue = plugin.defaultValue;
    if (name) {
      acc[name] = passedProps[name] !== void 0 ? passedProps[name] : defaultValue;
    }
    return acc;
  }, {});
  return Object.assign({}, passedProps, {}, pluginProps2);
}
__name(getExtendedPassedProps, "getExtendedPassedProps");
function getDataAttributeProps(reference, plugins) {
  var propKeys = plugins ? Object.keys(getExtendedPassedProps(Object.assign({}, defaultProps, {
    plugins
  }))) : defaultKeys;
  var props = propKeys.reduce(function(acc, key) {
    var valueAsString = (reference.getAttribute("data-tippy-" + key) || "").trim();
    if (!valueAsString) {
      return acc;
    }
    if (key === "content") {
      acc[key] = valueAsString;
    } else {
      try {
        acc[key] = JSON.parse(valueAsString);
      } catch (e) {
        acc[key] = valueAsString;
      }
    }
    return acc;
  }, {});
  return props;
}
__name(getDataAttributeProps, "getDataAttributeProps");
function evaluateProps(reference, props) {
  var out = Object.assign({}, props, {
    content: invokeWithArgsOrReturn(props.content, [reference])
  }, props.ignoreAttributes ? {} : getDataAttributeProps(reference, props.plugins));
  out.aria = Object.assign({}, defaultProps.aria, {}, out.aria);
  out.aria = {
    expanded: out.aria.expanded === "auto" ? props.interactive : out.aria.expanded,
    content: out.aria.content === "auto" ? props.interactive ? null : "describedby" : out.aria.content
  };
  return out;
}
__name(evaluateProps, "evaluateProps");
function validateProps(partialProps, plugins) {
  if (partialProps === void 0) {
    partialProps = {};
  }
  if (plugins === void 0) {
    plugins = [];
  }
  var keys = Object.keys(partialProps);
  keys.forEach(function(prop) {
    var nonPluginProps = removeProperties(defaultProps, Object.keys(pluginProps));
    var didPassUnknownProp = !hasOwnProperty(nonPluginProps, prop);
    if (didPassUnknownProp) {
      didPassUnknownProp = plugins.filter(function(plugin) {
        return plugin.name === prop;
      }).length === 0;
    }
    warnWhen(didPassUnknownProp, ["`" + prop + "`", "is not a valid prop. You may have spelled it incorrectly, or if it's", "a plugin, forgot to pass it in an array as props.plugins.", "\n\n", "All props: https://atomiks.github.io/tippyjs/v6/all-props/\n", "Plugins: https://atomiks.github.io/tippyjs/v6/plugins/"].join(" "));
  });
}
__name(validateProps, "validateProps");
function getChildren(popper) {
  var box = popper.firstElementChild;
  var boxChildren = arrayFrom(box.children);
  return {
    box,
    content: boxChildren.find(function(node) {
      return node.classList.contains(CONTENT_CLASS);
    }),
    arrow: boxChildren.find(function(node) {
      return node.classList.contains(ARROW_CLASS) || node.classList.contains(SVG_ARROW_CLASS);
    }),
    backdrop: boxChildren.find(function(node) {
      return node.classList.contains(BACKDROP_CLASS);
    })
  };
}
__name(getChildren, "getChildren");
var idCounter = 1;
var mouseMoveListeners = [];
var mountedInstances = [];
function createTippy(reference, passedProps) {
  var props = evaluateProps(reference, Object.assign({}, defaultProps, {}, getExtendedPassedProps(removeUndefinedProps(passedProps))));
  var showTimeout;
  var hideTimeout;
  var scheduleHideAnimationFrame;
  var isVisibleFromClick = false;
  var didHideDueToDocumentMouseDown = false;
  var didTouchMove = false;
  var ignoreOnFirstUpdate = false;
  var lastTriggerEvent;
  var currentTransitionEndListener;
  var onFirstUpdate;
  var listeners = [];
  var debouncedOnMouseMove = debounce(onMouseMove, props.interactiveDebounce);
  var currentTarget;
  var id = idCounter++;
  var popperInstance = null;
  var plugins = unique(props.plugins);
  var state = {
    isEnabled: true,
    isVisible: false,
    isDestroyed: false,
    isMounted: false,
    isShown: false
  };
  var instance = {
    id,
    reference,
    popper: div(),
    popperInstance,
    props,
    state,
    plugins,
    clearDelayTimeouts,
    setProps,
    setContent,
    show,
    hide,
    hideWithInteractivity,
    enable,
    disable,
    unmount,
    destroy
  };
  if (!props.render) {
    if (true) {
      errorWhen(true, "render() function has not been supplied.");
    }
    return instance;
  }
  var _props$render = props.render(instance), popper = _props$render.popper, onUpdate = _props$render.onUpdate;
  popper.setAttribute("data-tippy-root", "");
  popper.id = "tippy-" + instance.id;
  instance.popper = popper;
  reference._tippy = instance;
  popper._tippy = instance;
  var pluginsHooks = plugins.map(function(plugin) {
    return plugin.fn(instance);
  });
  var hasAriaExpanded = reference.hasAttribute("aria-expanded");
  addListeners();
  handleAriaExpandedAttribute();
  handleStyles();
  invokeHook("onCreate", [instance]);
  if (props.showOnCreate) {
    scheduleShow();
  }
  popper.addEventListener("mouseenter", function() {
    if (instance.props.interactive && instance.state.isVisible) {
      instance.clearDelayTimeouts();
    }
  });
  popper.addEventListener("mouseleave", function(event) {
    if (instance.props.interactive && instance.props.trigger.indexOf("mouseenter") >= 0) {
      getDocument().addEventListener("mousemove", debouncedOnMouseMove);
      debouncedOnMouseMove(event);
    }
  });
  return instance;
  function getNormalizedTouchSettings() {
    var touch = instance.props.touch;
    return Array.isArray(touch) ? touch : [touch, 0];
  }
  __name(getNormalizedTouchSettings, "getNormalizedTouchSettings");
  function getIsCustomTouchBehavior() {
    return getNormalizedTouchSettings()[0] === "hold";
  }
  __name(getIsCustomTouchBehavior, "getIsCustomTouchBehavior");
  function getIsDefaultRenderFn() {
    var _instance$props$rende;
    return !!((_instance$props$rende = instance.props.render) == null ? void 0 : _instance$props$rende.$$tippy);
  }
  __name(getIsDefaultRenderFn, "getIsDefaultRenderFn");
  function getCurrentTarget() {
    return currentTarget || reference;
  }
  __name(getCurrentTarget, "getCurrentTarget");
  function getDocument() {
    var parent = getCurrentTarget().parentNode;
    return parent ? getOwnerDocument(parent) : document;
  }
  __name(getDocument, "getDocument");
  function getDefaultTemplateChildren() {
    return getChildren(popper);
  }
  __name(getDefaultTemplateChildren, "getDefaultTemplateChildren");
  function getDelay(isShow) {
    if (instance.state.isMounted && !instance.state.isVisible || currentInput.isTouch || lastTriggerEvent && lastTriggerEvent.type === "focus") {
      return 0;
    }
    return getValueAtIndexOrReturn(instance.props.delay, isShow ? 0 : 1, defaultProps.delay);
  }
  __name(getDelay, "getDelay");
  function handleStyles() {
    popper.style.pointerEvents = instance.props.interactive && instance.state.isVisible ? "" : "none";
    popper.style.zIndex = "" + instance.props.zIndex;
  }
  __name(handleStyles, "handleStyles");
  function invokeHook(hook, args, shouldInvokePropsHook) {
    if (shouldInvokePropsHook === void 0) {
      shouldInvokePropsHook = true;
    }
    pluginsHooks.forEach(function(pluginHooks) {
      if (pluginHooks[hook]) {
        pluginHooks[hook].apply(void 0, args);
      }
    });
    if (shouldInvokePropsHook) {
      var _instance$props;
      (_instance$props = instance.props)[hook].apply(_instance$props, args);
    }
  }
  __name(invokeHook, "invokeHook");
  function handleAriaContentAttribute() {
    var aria = instance.props.aria;
    if (!aria.content) {
      return;
    }
    var attr = "aria-" + aria.content;
    var id2 = popper.id;
    var nodes = normalizeToArray(instance.props.triggerTarget || reference);
    nodes.forEach(function(node) {
      var currentValue = node.getAttribute(attr);
      if (instance.state.isVisible) {
        node.setAttribute(attr, currentValue ? currentValue + " " + id2 : id2);
      } else {
        var nextValue = currentValue && currentValue.replace(id2, "").trim();
        if (nextValue) {
          node.setAttribute(attr, nextValue);
        } else {
          node.removeAttribute(attr);
        }
      }
    });
  }
  __name(handleAriaContentAttribute, "handleAriaContentAttribute");
  function handleAriaExpandedAttribute() {
    if (hasAriaExpanded || !instance.props.aria.expanded) {
      return;
    }
    var nodes = normalizeToArray(instance.props.triggerTarget || reference);
    nodes.forEach(function(node) {
      if (instance.props.interactive) {
        node.setAttribute("aria-expanded", instance.state.isVisible && node === getCurrentTarget() ? "true" : "false");
      } else {
        node.removeAttribute("aria-expanded");
      }
    });
  }
  __name(handleAriaExpandedAttribute, "handleAriaExpandedAttribute");
  function cleanupInteractiveMouseListeners() {
    getDocument().removeEventListener("mousemove", debouncedOnMouseMove);
    mouseMoveListeners = mouseMoveListeners.filter(function(listener) {
      return listener !== debouncedOnMouseMove;
    });
  }
  __name(cleanupInteractiveMouseListeners, "cleanupInteractiveMouseListeners");
  function onDocumentPress(event) {
    if (currentInput.isTouch) {
      if (didTouchMove || event.type === "mousedown") {
        return;
      }
    }
    if (instance.props.interactive && popper.contains(event.target)) {
      return;
    }
    if (getCurrentTarget().contains(event.target)) {
      if (currentInput.isTouch) {
        return;
      }
      if (instance.state.isVisible && instance.props.trigger.indexOf("click") >= 0) {
        return;
      }
    } else {
      invokeHook("onClickOutside", [instance, event]);
    }
    if (instance.props.hideOnClick === true) {
      instance.clearDelayTimeouts();
      instance.hide();
      didHideDueToDocumentMouseDown = true;
      setTimeout(function() {
        didHideDueToDocumentMouseDown = false;
      });
      if (!instance.state.isMounted) {
        removeDocumentPress();
      }
    }
  }
  __name(onDocumentPress, "onDocumentPress");
  function onTouchMove() {
    didTouchMove = true;
  }
  __name(onTouchMove, "onTouchMove");
  function onTouchStart() {
    didTouchMove = false;
  }
  __name(onTouchStart, "onTouchStart");
  function addDocumentPress() {
    var doc = getDocument();
    doc.addEventListener("mousedown", onDocumentPress, true);
    doc.addEventListener("touchend", onDocumentPress, TOUCH_OPTIONS);
    doc.addEventListener("touchstart", onTouchStart, TOUCH_OPTIONS);
    doc.addEventListener("touchmove", onTouchMove, TOUCH_OPTIONS);
  }
  __name(addDocumentPress, "addDocumentPress");
  function removeDocumentPress() {
    var doc = getDocument();
    doc.removeEventListener("mousedown", onDocumentPress, true);
    doc.removeEventListener("touchend", onDocumentPress, TOUCH_OPTIONS);
    doc.removeEventListener("touchstart", onTouchStart, TOUCH_OPTIONS);
    doc.removeEventListener("touchmove", onTouchMove, TOUCH_OPTIONS);
  }
  __name(removeDocumentPress, "removeDocumentPress");
  function onTransitionedOut(duration, callback) {
    onTransitionEnd(duration, function() {
      if (!instance.state.isVisible && popper.parentNode && popper.parentNode.contains(popper)) {
        callback();
      }
    });
  }
  __name(onTransitionedOut, "onTransitionedOut");
  function onTransitionedIn(duration, callback) {
    onTransitionEnd(duration, callback);
  }
  __name(onTransitionedIn, "onTransitionedIn");
  function onTransitionEnd(duration, callback) {
    var box = getDefaultTemplateChildren().box;
    function listener(event) {
      if (event.target === box) {
        updateTransitionEndListener(box, "remove", listener);
        callback();
      }
    }
    __name(listener, "listener");
    if (duration === 0) {
      return callback();
    }
    updateTransitionEndListener(box, "remove", currentTransitionEndListener);
    updateTransitionEndListener(box, "add", listener);
    currentTransitionEndListener = listener;
  }
  __name(onTransitionEnd, "onTransitionEnd");
  function on(eventType, handler, options) {
    if (options === void 0) {
      options = false;
    }
    var nodes = normalizeToArray(instance.props.triggerTarget || reference);
    nodes.forEach(function(node) {
      node.addEventListener(eventType, handler, options);
      listeners.push({
        node,
        eventType,
        handler,
        options
      });
    });
  }
  __name(on, "on");
  function addListeners() {
    if (getIsCustomTouchBehavior()) {
      on("touchstart", onTrigger2, {
        passive: true
      });
      on("touchend", onMouseLeave, {
        passive: true
      });
    }
    splitBySpaces(instance.props.trigger).forEach(function(eventType) {
      if (eventType === "manual") {
        return;
      }
      on(eventType, onTrigger2);
      switch (eventType) {
        case "mouseenter":
          on("mouseleave", onMouseLeave);
          break;
        case "focus":
          on(isIE ? "focusout" : "blur", onBlurOrFocusOut);
          break;
        case "focusin":
          on("focusout", onBlurOrFocusOut);
          break;
      }
    });
  }
  __name(addListeners, "addListeners");
  function removeListeners() {
    listeners.forEach(function(_ref) {
      var node = _ref.node, eventType = _ref.eventType, handler = _ref.handler, options = _ref.options;
      node.removeEventListener(eventType, handler, options);
    });
    listeners = [];
  }
  __name(removeListeners, "removeListeners");
  function onTrigger2(event) {
    var _lastTriggerEvent;
    var shouldScheduleClickHide = false;
    if (!instance.state.isEnabled || isEventListenerStopped(event) || didHideDueToDocumentMouseDown) {
      return;
    }
    var wasFocused = ((_lastTriggerEvent = lastTriggerEvent) == null ? void 0 : _lastTriggerEvent.type) === "focus";
    lastTriggerEvent = event;
    currentTarget = event.currentTarget;
    handleAriaExpandedAttribute();
    if (!instance.state.isVisible && isMouseEvent(event)) {
      mouseMoveListeners.forEach(function(listener) {
        return listener(event);
      });
    }
    if (event.type === "click" && (instance.props.trigger.indexOf("mouseenter") < 0 || isVisibleFromClick) && instance.props.hideOnClick !== false && instance.state.isVisible) {
      shouldScheduleClickHide = true;
    } else {
      scheduleShow(event);
    }
    if (event.type === "click") {
      isVisibleFromClick = !shouldScheduleClickHide;
    }
    if (shouldScheduleClickHide && !wasFocused) {
      scheduleHide(event);
    }
  }
  __name(onTrigger2, "onTrigger");
  function onMouseMove(event) {
    var target = event.target;
    var isCursorOverReferenceOrPopper = getCurrentTarget().contains(target) || popper.contains(target);
    if (event.type === "mousemove" && isCursorOverReferenceOrPopper) {
      return;
    }
    var popperTreeData = getNestedPopperTree().concat(popper).map(function(popper2) {
      var _instance$popperInsta;
      var instance2 = popper2._tippy;
      var state2 = (_instance$popperInsta = instance2.popperInstance) == null ? void 0 : _instance$popperInsta.state;
      if (state2) {
        return {
          popperRect: popper2.getBoundingClientRect(),
          popperState: state2,
          props
        };
      }
      return null;
    }).filter(Boolean);
    if (isCursorOutsideInteractiveBorder(popperTreeData, event)) {
      cleanupInteractiveMouseListeners();
      scheduleHide(event);
    }
  }
  __name(onMouseMove, "onMouseMove");
  function onMouseLeave(event) {
    var shouldBail = isEventListenerStopped(event) || instance.props.trigger.indexOf("click") >= 0 && isVisibleFromClick;
    if (shouldBail) {
      return;
    }
    if (instance.props.interactive) {
      instance.hideWithInteractivity(event);
      return;
    }
    scheduleHide(event);
  }
  __name(onMouseLeave, "onMouseLeave");
  function onBlurOrFocusOut(event) {
    if (instance.props.trigger.indexOf("focusin") < 0 && event.target !== getCurrentTarget()) {
      return;
    }
    if (instance.props.interactive && event.relatedTarget && popper.contains(event.relatedTarget)) {
      return;
    }
    scheduleHide(event);
  }
  __name(onBlurOrFocusOut, "onBlurOrFocusOut");
  function isEventListenerStopped(event) {
    return currentInput.isTouch ? getIsCustomTouchBehavior() !== event.type.indexOf("touch") >= 0 : false;
  }
  __name(isEventListenerStopped, "isEventListenerStopped");
  function createPopperInstance() {
    destroyPopperInstance();
    var _instance$props2 = instance.props, popperOptions = _instance$props2.popperOptions, placement = _instance$props2.placement, offset = _instance$props2.offset, getReferenceClientRect = _instance$props2.getReferenceClientRect, moveTransition = _instance$props2.moveTransition;
    var arrow = getIsDefaultRenderFn() ? getChildren(popper).arrow : null;
    var computedReference = getReferenceClientRect ? {
      getBoundingClientRect: getReferenceClientRect,
      contextElement: getReferenceClientRect.contextElement || getCurrentTarget()
    } : reference;
    var tippyModifier = {
      name: "$$tippy",
      enabled: true,
      phase: "beforeWrite",
      requires: ["computeStyles"],
      fn: /* @__PURE__ */ __name(function fn2(_ref2) {
        var state2 = _ref2.state;
        if (getIsDefaultRenderFn()) {
          var _getDefaultTemplateCh = getDefaultTemplateChildren(), box = _getDefaultTemplateCh.box;
          ["placement", "reference-hidden", "escaped"].forEach(function(attr) {
            if (attr === "placement") {
              box.setAttribute("data-placement", state2.placement);
            } else {
              if (state2.attributes.popper["data-popper-" + attr]) {
                box.setAttribute("data-" + attr, "");
              } else {
                box.removeAttribute("data-" + attr);
              }
            }
          });
          state2.attributes.popper = {};
        }
      }, "fn")
    };
    var modifiers = [{
      name: "offset",
      options: {
        offset
      }
    }, {
      name: "preventOverflow",
      options: {
        padding: {
          top: 2,
          bottom: 2,
          left: 5,
          right: 5
        }
      }
    }, {
      name: "flip",
      options: {
        padding: 5
      }
    }, {
      name: "computeStyles",
      options: {
        adaptive: !moveTransition
      }
    }, tippyModifier];
    if (getIsDefaultRenderFn() && arrow) {
      modifiers.push({
        name: "arrow",
        options: {
          element: arrow,
          padding: 3
        }
      });
    }
    modifiers.push.apply(modifiers, (popperOptions == null ? void 0 : popperOptions.modifiers) || []);
    instance.popperInstance = createPopper(computedReference, popper, Object.assign({}, popperOptions, {
      placement,
      onFirstUpdate,
      modifiers
    }));
  }
  __name(createPopperInstance, "createPopperInstance");
  function destroyPopperInstance() {
    if (instance.popperInstance) {
      instance.popperInstance.destroy();
      instance.popperInstance = null;
    }
  }
  __name(destroyPopperInstance, "destroyPopperInstance");
  function mount() {
    var appendTo2 = instance.props.appendTo;
    var parentNode;
    var node = getCurrentTarget();
    if (instance.props.interactive && appendTo2 === defaultProps.appendTo || appendTo2 === "parent") {
      parentNode = node.parentNode;
    } else {
      parentNode = invokeWithArgsOrReturn(appendTo2, [node]);
    }
    if (!parentNode.contains(popper)) {
      parentNode.appendChild(popper);
    }
    createPopperInstance();
    if (true) {
      warnWhen(instance.props.interactive && appendTo2 === defaultProps.appendTo && node.nextElementSibling !== popper, ["Interactive tippy element may not be accessible via keyboard", "navigation because it is not directly after the reference element", "in the DOM source order.", "\n\n", "Using a wrapper <div> or <span> tag around the reference element", "solves this by creating a new parentNode context.", "\n\n", "Specifying `appendTo: document.body` silences this warning, but it", "assumes you are using a focus management solution to handle", "keyboard navigation.", "\n\n", "See: https://atomiks.github.io/tippyjs/v6/accessibility/#interactivity"].join(" "));
    }
  }
  __name(mount, "mount");
  function getNestedPopperTree() {
    return arrayFrom(popper.querySelectorAll("[data-tippy-root]"));
  }
  __name(getNestedPopperTree, "getNestedPopperTree");
  function scheduleShow(event) {
    instance.clearDelayTimeouts();
    if (event) {
      invokeHook("onTrigger", [instance, event]);
    }
    addDocumentPress();
    var delay = getDelay(true);
    var _getNormalizedTouchSe = getNormalizedTouchSettings(), touchValue = _getNormalizedTouchSe[0], touchDelay = _getNormalizedTouchSe[1];
    if (currentInput.isTouch && touchValue === "hold" && touchDelay) {
      delay = touchDelay;
    }
    if (delay) {
      showTimeout = setTimeout(function() {
        instance.show();
      }, delay);
    } else {
      instance.show();
    }
  }
  __name(scheduleShow, "scheduleShow");
  function scheduleHide(event) {
    instance.clearDelayTimeouts();
    invokeHook("onUntrigger", [instance, event]);
    if (!instance.state.isVisible) {
      removeDocumentPress();
      return;
    }
    if (instance.props.trigger.indexOf("mouseenter") >= 0 && instance.props.trigger.indexOf("click") >= 0 && ["mouseleave", "mousemove"].indexOf(event.type) >= 0 && isVisibleFromClick) {
      return;
    }
    var delay = getDelay(false);
    if (delay) {
      hideTimeout = setTimeout(function() {
        if (instance.state.isVisible) {
          instance.hide();
        }
      }, delay);
    } else {
      scheduleHideAnimationFrame = requestAnimationFrame(function() {
        instance.hide();
      });
    }
  }
  __name(scheduleHide, "scheduleHide");
  function enable() {
    instance.state.isEnabled = true;
  }
  __name(enable, "enable");
  function disable() {
    instance.hide();
    instance.state.isEnabled = false;
  }
  __name(disable, "disable");
  function clearDelayTimeouts() {
    clearTimeout(showTimeout);
    clearTimeout(hideTimeout);
    cancelAnimationFrame(scheduleHideAnimationFrame);
  }
  __name(clearDelayTimeouts, "clearDelayTimeouts");
  function setProps(partialProps) {
    if (true) {
      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("setProps"));
    }
    if (instance.state.isDestroyed) {
      return;
    }
    invokeHook("onBeforeUpdate", [instance, partialProps]);
    removeListeners();
    var prevProps = instance.props;
    var nextProps = evaluateProps(reference, Object.assign({}, instance.props, {}, partialProps, {
      ignoreAttributes: true
    }));
    instance.props = nextProps;
    addListeners();
    if (prevProps.interactiveDebounce !== nextProps.interactiveDebounce) {
      cleanupInteractiveMouseListeners();
      debouncedOnMouseMove = debounce(onMouseMove, nextProps.interactiveDebounce);
    }
    if (prevProps.triggerTarget && !nextProps.triggerTarget) {
      normalizeToArray(prevProps.triggerTarget).forEach(function(node) {
        node.removeAttribute("aria-expanded");
      });
    } else if (nextProps.triggerTarget) {
      reference.removeAttribute("aria-expanded");
    }
    handleAriaExpandedAttribute();
    handleStyles();
    if (onUpdate) {
      onUpdate(prevProps, nextProps);
    }
    if (instance.popperInstance) {
      createPopperInstance();
      getNestedPopperTree().forEach(function(nestedPopper) {
        requestAnimationFrame(nestedPopper._tippy.popperInstance.forceUpdate);
      });
    }
    invokeHook("onAfterUpdate", [instance, partialProps]);
  }
  __name(setProps, "setProps");
  function setContent(content) {
    instance.setProps({
      content
    });
  }
  __name(setContent, "setContent");
  function show() {
    if (true) {
      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("show"));
    }
    var isAlreadyVisible = instance.state.isVisible;
    var isDestroyed = instance.state.isDestroyed;
    var isDisabled = !instance.state.isEnabled;
    var isTouchAndTouchDisabled = currentInput.isTouch && !instance.props.touch;
    var duration = getValueAtIndexOrReturn(instance.props.duration, 0, defaultProps.duration);
    if (isAlreadyVisible || isDestroyed || isDisabled || isTouchAndTouchDisabled) {
      return;
    }
    if (getCurrentTarget().hasAttribute("disabled")) {
      return;
    }
    invokeHook("onShow", [instance], false);
    if (instance.props.onShow(instance) === false) {
      return;
    }
    instance.state.isVisible = true;
    if (getIsDefaultRenderFn()) {
      popper.style.visibility = "visible";
    }
    handleStyles();
    addDocumentPress();
    if (!instance.state.isMounted) {
      popper.style.transition = "none";
    }
    if (getIsDefaultRenderFn()) {
      var _getDefaultTemplateCh2 = getDefaultTemplateChildren(), box = _getDefaultTemplateCh2.box, content = _getDefaultTemplateCh2.content;
      setTransitionDuration([box, content], 0);
    }
    onFirstUpdate = /* @__PURE__ */ __name(function onFirstUpdate2() {
      var _instance$popperInsta2;
      if (!instance.state.isVisible || ignoreOnFirstUpdate) {
        return;
      }
      ignoreOnFirstUpdate = true;
      void popper.offsetHeight;
      popper.style.transition = instance.props.moveTransition;
      if (getIsDefaultRenderFn() && instance.props.animation) {
        var _getDefaultTemplateCh3 = getDefaultTemplateChildren(), _box = _getDefaultTemplateCh3.box, _content = _getDefaultTemplateCh3.content;
        setTransitionDuration([_box, _content], duration);
        setVisibilityState([_box, _content], "visible");
      }
      handleAriaContentAttribute();
      handleAriaExpandedAttribute();
      pushIfUnique(mountedInstances, instance);
      (_instance$popperInsta2 = instance.popperInstance) == null ? void 0 : _instance$popperInsta2.forceUpdate();
      instance.state.isMounted = true;
      invokeHook("onMount", [instance]);
      if (instance.props.animation && getIsDefaultRenderFn()) {
        onTransitionedIn(duration, function() {
          instance.state.isShown = true;
          invokeHook("onShown", [instance]);
        });
      }
    }, "onFirstUpdate");
    mount();
  }
  __name(show, "show");
  function hide() {
    if (true) {
      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("hide"));
    }
    var isAlreadyHidden = !instance.state.isVisible;
    var isDestroyed = instance.state.isDestroyed;
    var isDisabled = !instance.state.isEnabled;
    var duration = getValueAtIndexOrReturn(instance.props.duration, 1, defaultProps.duration);
    if (isAlreadyHidden || isDestroyed || isDisabled) {
      return;
    }
    invokeHook("onHide", [instance], false);
    if (instance.props.onHide(instance) === false) {
      return;
    }
    instance.state.isVisible = false;
    instance.state.isShown = false;
    ignoreOnFirstUpdate = false;
    isVisibleFromClick = false;
    if (getIsDefaultRenderFn()) {
      popper.style.visibility = "hidden";
    }
    cleanupInteractiveMouseListeners();
    removeDocumentPress();
    handleStyles();
    if (getIsDefaultRenderFn()) {
      var _getDefaultTemplateCh4 = getDefaultTemplateChildren(), box = _getDefaultTemplateCh4.box, content = _getDefaultTemplateCh4.content;
      if (instance.props.animation) {
        setTransitionDuration([box, content], duration);
        setVisibilityState([box, content], "hidden");
      }
    }
    handleAriaContentAttribute();
    handleAriaExpandedAttribute();
    if (instance.props.animation) {
      if (getIsDefaultRenderFn()) {
        onTransitionedOut(duration, instance.unmount);
      }
    } else {
      instance.unmount();
    }
  }
  __name(hide, "hide");
  function hideWithInteractivity(event) {
    if (true) {
      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("hideWithInteractivity"));
    }
    getDocument().addEventListener("mousemove", debouncedOnMouseMove);
    pushIfUnique(mouseMoveListeners, debouncedOnMouseMove);
    debouncedOnMouseMove(event);
  }
  __name(hideWithInteractivity, "hideWithInteractivity");
  function unmount() {
    if (true) {
      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("unmount"));
    }
    if (instance.state.isVisible) {
      instance.hide();
    }
    if (!instance.state.isMounted) {
      return;
    }
    destroyPopperInstance();
    getNestedPopperTree().forEach(function(nestedPopper) {
      nestedPopper._tippy.unmount();
    });
    if (popper.parentNode) {
      popper.parentNode.removeChild(popper);
    }
    mountedInstances = mountedInstances.filter(function(i) {
      return i !== instance;
    });
    instance.state.isMounted = false;
    invokeHook("onHidden", [instance]);
  }
  __name(unmount, "unmount");
  function destroy() {
    if (true) {
      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("destroy"));
    }
    if (instance.state.isDestroyed) {
      return;
    }
    instance.clearDelayTimeouts();
    instance.unmount();
    removeListeners();
    delete reference._tippy;
    instance.state.isDestroyed = true;
    invokeHook("onDestroy", [instance]);
  }
  __name(destroy, "destroy");
}
__name(createTippy, "createTippy");
function tippy(targets, optionalProps) {
  if (optionalProps === void 0) {
    optionalProps = {};
  }
  var plugins = defaultProps.plugins.concat(optionalProps.plugins || []);
  if (true) {
    validateTargets(targets);
    validateProps(optionalProps, plugins);
  }
  bindGlobalEventListeners();
  var passedProps = Object.assign({}, optionalProps, {
    plugins
  });
  var elements = getArrayOfElements(targets);
  if (true) {
    var isSingleContentElement = isElement(passedProps.content);
    var isMoreThanOneReferenceElement = elements.length > 1;
    warnWhen(isSingleContentElement && isMoreThanOneReferenceElement, ["tippy() was passed an Element as the `content` prop, but more than", "one tippy instance was created by this invocation. This means the", "content element will only be appended to the last tippy instance.", "\n\n", "Instead, pass the .innerHTML of the element, or use a function that", "returns a cloned version of the element instead.", "\n\n", "1) content: element.innerHTML\n", "2) content: () => element.cloneNode(true)"].join(" "));
  }
  var instances = elements.reduce(function(acc, reference) {
    var instance = reference && createTippy(reference, passedProps);
    if (instance) {
      acc.push(instance);
    }
    return acc;
  }, []);
  return isElement(targets) ? instances[0] : instances;
}
__name(tippy, "tippy");
tippy.defaultProps = defaultProps;
tippy.setDefaultProps = setDefaultProps;
tippy.currentInput = currentInput;
var applyStylesModifier = Object.assign({}, applyStyles_default, {
  effect: /* @__PURE__ */ __name(function effect(_ref) {
    var state = _ref.state;
    var initialStyles = {
      popper: {
        position: state.options.strategy,
        left: "0",
        top: "0",
        margin: "0"
      },
      arrow: {
        position: "absolute"
      },
      reference: {}
    };
    Object.assign(state.elements.popper.style, initialStyles.popper);
    state.styles = initialStyles;
    if (state.elements.arrow) {
      Object.assign(state.elements.arrow.style, initialStyles.arrow);
    }
  }, "effect")
});
var createSingleton = /* @__PURE__ */ __name(function createSingleton2(tippyInstances, optionalProps) {
  var _optionalProps$popper;
  if (optionalProps === void 0) {
    optionalProps = {};
  }
  if (true) {
    errorWhen(!Array.isArray(tippyInstances), ["The first argument passed to createSingleton() must be an array of", "tippy instances. The passed value was", String(tippyInstances)].join(" "));
  }
  var individualInstances = tippyInstances;
  var references = [];
  var currentTarget;
  var overrides = optionalProps.overrides;
  var interceptSetPropsCleanups = [];
  var shownOnCreate = false;
  function setReferences() {
    references = individualInstances.map(function(instance) {
      return instance.reference;
    });
  }
  __name(setReferences, "setReferences");
  function enableInstances(isEnabled) {
    individualInstances.forEach(function(instance) {
      if (isEnabled) {
        instance.enable();
      } else {
        instance.disable();
      }
    });
  }
  __name(enableInstances, "enableInstances");
  function interceptSetProps(singleton2) {
    return individualInstances.map(function(instance) {
      var originalSetProps2 = instance.setProps;
      instance.setProps = function(props) {
        originalSetProps2(props);
        if (instance.reference === currentTarget) {
          singleton2.setProps(props);
        }
      };
      return function() {
        instance.setProps = originalSetProps2;
      };
    });
  }
  __name(interceptSetProps, "interceptSetProps");
  function prepareInstance(singleton2, target) {
    var index = references.indexOf(target);
    if (target === currentTarget) {
      return;
    }
    currentTarget = target;
    var overrideProps = (overrides || []).concat("content").reduce(function(acc, prop) {
      acc[prop] = individualInstances[index].props[prop];
      return acc;
    }, {});
    singleton2.setProps(Object.assign({}, overrideProps, {
      getReferenceClientRect: typeof overrideProps.getReferenceClientRect === "function" ? overrideProps.getReferenceClientRect : function() {
        return target.getBoundingClientRect();
      }
    }));
  }
  __name(prepareInstance, "prepareInstance");
  enableInstances(false);
  setReferences();
  var plugin = {
    fn: /* @__PURE__ */ __name(function fn2() {
      return {
        onDestroy: /* @__PURE__ */ __name(function onDestroy2() {
          enableInstances(true);
        }, "onDestroy"),
        onHidden: /* @__PURE__ */ __name(function onHidden2() {
          currentTarget = null;
        }, "onHidden"),
        onClickOutside: /* @__PURE__ */ __name(function onClickOutside2(instance) {
          if (instance.props.showOnCreate && !shownOnCreate) {
            shownOnCreate = true;
            currentTarget = null;
          }
        }, "onClickOutside"),
        onShow: /* @__PURE__ */ __name(function onShow2(instance) {
          if (instance.props.showOnCreate && !shownOnCreate) {
            shownOnCreate = true;
            prepareInstance(instance, references[0]);
          }
        }, "onShow"),
        onTrigger: /* @__PURE__ */ __name(function onTrigger2(instance, event) {
          prepareInstance(instance, event.currentTarget);
        }, "onTrigger")
      };
    }, "fn")
  };
  var singleton = tippy(div(), Object.assign({}, removeProperties(optionalProps, ["overrides"]), {
    plugins: [plugin].concat(optionalProps.plugins || []),
    triggerTarget: references,
    popperOptions: Object.assign({}, optionalProps.popperOptions, {
      modifiers: [].concat(((_optionalProps$popper = optionalProps.popperOptions) == null ? void 0 : _optionalProps$popper.modifiers) || [], [applyStylesModifier])
    })
  }));
  var originalShow = singleton.show;
  singleton.show = function(target) {
    originalShow();
    if (!currentTarget && target == null) {
      return prepareInstance(singleton, references[0]);
    }
    if (currentTarget && target == null) {
      return;
    }
    if (typeof target === "number") {
      return references[target] && prepareInstance(singleton, references[target]);
    }
    if (individualInstances.includes(target)) {
      var ref = target.reference;
      return prepareInstance(singleton, ref);
    }
    if (references.includes(target)) {
      return prepareInstance(singleton, target);
    }
  };
  singleton.showNext = function() {
    var first = references[0];
    if (!currentTarget) {
      return singleton.show(0);
    }
    var index = references.indexOf(currentTarget);
    singleton.show(references[index + 1] || first);
  };
  singleton.showPrevious = function() {
    var last = references[references.length - 1];
    if (!currentTarget) {
      return singleton.show(last);
    }
    var index = references.indexOf(currentTarget);
    var target = references[index - 1] || last;
    singleton.show(target);
  };
  var originalSetProps = singleton.setProps;
  singleton.setProps = function(props) {
    overrides = props.overrides || overrides;
    originalSetProps(props);
  };
  singleton.setInstances = function(nextInstances) {
    enableInstances(true);
    interceptSetPropsCleanups.forEach(function(fn2) {
      return fn2();
    });
    individualInstances = nextInstances;
    enableInstances(false);
    setReferences();
    interceptSetProps(singleton);
    singleton.setProps({
      triggerTarget: references
    });
  };
  interceptSetPropsCleanups = interceptSetProps(singleton);
  return singleton;
}, "createSingleton");
tippy.setDefaultProps({
  animation: false
});
var tippy_headless_esm_default = tippy;

// ../.yarn/$$virtual/@tippyjs-react-virtual-97ed4b720c/0/cache/@tippyjs-react-npm-4.2.5-8f6cb660c3-f886801245.zip/node_modules/@tippyjs/react/headless/dist/tippy-react-headless.esm.js
var import_react = __toModule(require_react());
var import_react_dom = __toModule(require_react_dom());
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
__name(_objectWithoutPropertiesLoose, "_objectWithoutPropertiesLoose");
var isBrowser2 = typeof window !== "undefined" && typeof document !== "undefined";
function preserveRef(ref, node) {
  if (ref) {
    if (typeof ref === "function") {
      ref(node);
    }
    if ({}.hasOwnProperty.call(ref, "current")) {
      ref.current = node;
    }
  }
}
__name(preserveRef, "preserveRef");
function ssrSafeCreateDiv() {
  return isBrowser2 && document.createElement("div");
}
__name(ssrSafeCreateDiv, "ssrSafeCreateDiv");
function toDataAttributes(attrs) {
  var dataAttrs = {
    "data-placement": attrs.placement
  };
  if (attrs.referenceHidden) {
    dataAttrs["data-reference-hidden"] = "";
  }
  if (attrs.escaped) {
    dataAttrs["data-escaped"] = "";
  }
  return dataAttrs;
}
__name(toDataAttributes, "toDataAttributes");
function deepEqual(x, y) {
  if (x === y) {
    return true;
  } else if (typeof x === "object" && x != null && typeof y === "object" && y != null) {
    if (Object.keys(x).length !== Object.keys(y).length) {
      return false;
    }
    for (var prop in x) {
      if (y.hasOwnProperty(prop)) {
        if (!deepEqual(x[prop], y[prop])) {
          return false;
        }
      } else {
        return false;
      }
    }
    return true;
  } else {
    return false;
  }
}
__name(deepEqual, "deepEqual");
function uniqueByShape(arr) {
  var output = [];
  arr.forEach(function(item) {
    if (!output.find(function(outputItem) {
      return deepEqual(item, outputItem);
    })) {
      output.push(item);
    }
  });
  return output;
}
__name(uniqueByShape, "uniqueByShape");
function deepPreserveProps(instanceProps, componentProps) {
  var _instanceProps$popper, _componentProps$poppe;
  return Object.assign({}, componentProps, {
    popperOptions: Object.assign({}, instanceProps.popperOptions, componentProps.popperOptions, {
      modifiers: uniqueByShape([].concat(((_instanceProps$popper = instanceProps.popperOptions) == null ? void 0 : _instanceProps$popper.modifiers) || [], ((_componentProps$poppe = componentProps.popperOptions) == null ? void 0 : _componentProps$poppe.modifiers) || []))
    })
  });
}
__name(deepPreserveProps, "deepPreserveProps");
var useIsomorphicLayoutEffect = isBrowser2 ? import_react.useLayoutEffect : import_react.useEffect;
function useMutableBox(initialValue) {
  var ref = (0, import_react.useRef)();
  if (!ref.current) {
    ref.current = typeof initialValue === "function" ? initialValue() : initialValue;
  }
  return ref.current;
}
__name(useMutableBox, "useMutableBox");
function updateClassName(box, action, classNames) {
  classNames.split(/\s+/).forEach(function(name) {
    if (name) {
      box.classList[action](name);
    }
  });
}
__name(updateClassName, "updateClassName");
var classNamePlugin = {
  name: "className",
  defaultValue: "",
  fn: /* @__PURE__ */ __name(function fn(instance) {
    var box = instance.popper.firstElementChild;
    var isDefaultRenderFn = /* @__PURE__ */ __name(function isDefaultRenderFn2() {
      var _instance$props$rende;
      return !!((_instance$props$rende = instance.props.render) == null ? void 0 : _instance$props$rende.$$tippy);
    }, "isDefaultRenderFn");
    function add() {
      if (instance.props.className && !isDefaultRenderFn()) {
        if (true) {
          console.warn(["@tippyjs/react: Cannot use `className` prop in conjunction with", "`render` prop. Place the className on the element you are", "rendering."].join(" "));
        }
        return;
      }
      updateClassName(box, "add", instance.props.className);
    }
    __name(add, "add");
    function remove() {
      if (isDefaultRenderFn()) {
        updateClassName(box, "remove", instance.props.className);
      }
    }
    __name(remove, "remove");
    return {
      onCreate: add,
      onBeforeUpdate: remove,
      onAfterUpdate: add
    };
  }, "fn")
};
function TippyGenerator(tippy2) {
  function Tippy(_ref) {
    var children = _ref.children, content = _ref.content, visible = _ref.visible, singleton = _ref.singleton, render2 = _ref.render, reference = _ref.reference, _ref$disabled = _ref.disabled, disabled = _ref$disabled === void 0 ? false : _ref$disabled, _ref$ignoreAttributes = _ref.ignoreAttributes, ignoreAttributes = _ref$ignoreAttributes === void 0 ? true : _ref$ignoreAttributes, __source = _ref.__source, __self = _ref.__self, restOfNativeProps = _objectWithoutPropertiesLoose(_ref, ["children", "content", "visible", "singleton", "render", "reference", "disabled", "ignoreAttributes", "__source", "__self"]);
    var isControlledMode = visible !== void 0;
    var isSingletonMode = singleton !== void 0;
    var _useState = (0, import_react.useState)(false), mounted = _useState[0], setMounted = _useState[1];
    var _useState2 = (0, import_react.useState)({}), attrs = _useState2[0], setAttrs = _useState2[1];
    var _useState3 = (0, import_react.useState)(), singletonContent = _useState3[0], setSingletonContent = _useState3[1];
    var mutableBox = useMutableBox(function() {
      return {
        container: ssrSafeCreateDiv(),
        renders: 1
      };
    });
    var props = Object.assign({
      ignoreAttributes
    }, restOfNativeProps, {
      content: mutableBox.container
    });
    if (isControlledMode) {
      if (true) {
        ["trigger", "hideOnClick", "showOnCreate"].forEach(function(nativeStateProp) {
          if (props[nativeStateProp] !== void 0) {
            console.warn(["@tippyjs/react: Cannot specify `" + nativeStateProp + "` prop in", "controlled mode (`visible` prop)"].join(" "));
          }
        });
      }
      props.trigger = "manual";
      props.hideOnClick = false;
    }
    if (isSingletonMode) {
      disabled = true;
    }
    var computedProps = props;
    var plugins = props.plugins || [];
    if (render2) {
      computedProps = Object.assign({}, props, {
        plugins: isSingletonMode ? [].concat(plugins, [{
          fn: /* @__PURE__ */ __name(function fn2() {
            return {
              onTrigger: /* @__PURE__ */ __name(function onTrigger2(_, event) {
                var _singleton$data$child = singleton.data.children.find(function(_ref2) {
                  var instance = _ref2.instance;
                  return instance.reference === event.currentTarget;
                }), content2 = _singleton$data$child.content;
                setSingletonContent(content2);
              }, "onTrigger")
            };
          }, "fn")
        }]) : plugins,
        render: /* @__PURE__ */ __name(function render3() {
          return {
            popper: mutableBox.container
          };
        }, "render")
      });
    }
    var deps = [reference].concat(children ? [children.type] : []);
    useIsomorphicLayoutEffect(function() {
      var element = reference;
      if (reference && reference.hasOwnProperty("current")) {
        element = reference.current;
      }
      var instance = tippy2(element || mutableBox.ref || ssrSafeCreateDiv(), Object.assign({}, computedProps, {
        plugins: [classNamePlugin].concat(props.plugins || [])
      }));
      mutableBox.instance = instance;
      if (disabled) {
        instance.disable();
      }
      if (visible) {
        instance.show();
      }
      if (isSingletonMode) {
        singleton.hook({
          instance,
          content,
          props: computedProps
        });
      }
      setMounted(true);
      return function() {
        instance.destroy();
        singleton == null ? void 0 : singleton.cleanup(instance);
      };
    }, deps);
    useIsomorphicLayoutEffect(function() {
      var _instance$popperInsta;
      if (mutableBox.renders === 1) {
        mutableBox.renders++;
        return;
      }
      var instance = mutableBox.instance;
      instance.setProps(deepPreserveProps(instance.props, computedProps));
      (_instance$popperInsta = instance.popperInstance) == null ? void 0 : _instance$popperInsta.forceUpdate();
      if (disabled) {
        instance.disable();
      } else {
        instance.enable();
      }
      if (isControlledMode) {
        if (visible) {
          instance.show();
        } else {
          instance.hide();
        }
      }
      if (isSingletonMode) {
        singleton.hook({
          instance,
          content,
          props: computedProps
        });
      }
    });
    useIsomorphicLayoutEffect(function() {
      var _instance$props$poppe;
      if (!render2) {
        return;
      }
      var instance = mutableBox.instance;
      instance.setProps({
        popperOptions: Object.assign({}, instance.props.popperOptions, {
          modifiers: [].concat((((_instance$props$poppe = instance.props.popperOptions) == null ? void 0 : _instance$props$poppe.modifiers) || []).filter(function(_ref3) {
            var name = _ref3.name;
            return name !== "$$tippyReact";
          }), [{
            name: "$$tippyReact",
            enabled: true,
            phase: "beforeWrite",
            requires: ["computeStyles"],
            fn: /* @__PURE__ */ __name(function fn2(_ref4) {
              var _state$modifiersData;
              var state = _ref4.state;
              var hideData = (_state$modifiersData = state.modifiersData) == null ? void 0 : _state$modifiersData.hide;
              if (attrs.placement !== state.placement || attrs.referenceHidden !== (hideData == null ? void 0 : hideData.isReferenceHidden) || attrs.escaped !== (hideData == null ? void 0 : hideData.hasPopperEscaped)) {
                setAttrs({
                  placement: state.placement,
                  referenceHidden: hideData == null ? void 0 : hideData.isReferenceHidden,
                  escaped: hideData == null ? void 0 : hideData.hasPopperEscaped
                });
              }
              state.attributes.popper = {};
            }, "fn")
          }])
        })
      });
    }, [attrs.placement, attrs.referenceHidden, attrs.escaped].concat(deps));
    return import_react.default.createElement(import_react.default.Fragment, null, children ? (0, import_react.cloneElement)(children, {
      ref: /* @__PURE__ */ __name(function ref(node) {
        mutableBox.ref = node;
        preserveRef(children.ref, node);
      }, "ref")
    }) : null, mounted && (0, import_react_dom.createPortal)(render2 ? render2(toDataAttributes(attrs), singletonContent, mutableBox.instance) : content, mutableBox.container));
  }
  __name(Tippy, "Tippy");
  return Tippy;
}
__name(TippyGenerator, "TippyGenerator");
function useSingletonGenerator(createSingleton3) {
  return /* @__PURE__ */ __name(function useSingleton2(_temp) {
    var _ref = _temp === void 0 ? {} : _temp, _ref$disabled = _ref.disabled, disabled = _ref$disabled === void 0 ? false : _ref$disabled, _ref$overrides = _ref.overrides, overrides = _ref$overrides === void 0 ? [] : _ref$overrides;
    var _useState = (0, import_react.useState)(false), mounted = _useState[0], setMounted = _useState[1];
    var mutableBox = useMutableBox({
      children: [],
      renders: 1
    });
    useIsomorphicLayoutEffect(function() {
      if (!mounted) {
        setMounted(true);
        return;
      }
      var children = mutableBox.children, sourceData = mutableBox.sourceData;
      if (!sourceData) {
        if (true) {
          console.error(["@tippyjs/react: The `source` variable from `useSingleton()` has", "not been passed to a <Tippy /> component."].join(" "));
        }
        return;
      }
      var instance = createSingleton3(children.map(function(child) {
        return child.instance;
      }), Object.assign({}, sourceData.props, {
        popperOptions: sourceData.instance.props.popperOptions,
        overrides,
        plugins: [classNamePlugin].concat(sourceData.props.plugins || [])
      }));
      mutableBox.instance = instance;
      if (disabled) {
        instance.disable();
      }
      return function() {
        instance.destroy();
        mutableBox.children = children.filter(function(_ref2) {
          var instance2 = _ref2.instance;
          return !instance2.state.isDestroyed;
        });
      };
    }, [mounted]);
    useIsomorphicLayoutEffect(function() {
      if (!mounted) {
        return;
      }
      if (mutableBox.renders === 1) {
        mutableBox.renders++;
        return;
      }
      var children = mutableBox.children, instance = mutableBox.instance, sourceData = mutableBox.sourceData;
      if (!(instance && sourceData)) {
        return;
      }
      var _sourceData$props = sourceData.props, content = _sourceData$props.content, props = _objectWithoutPropertiesLoose(_sourceData$props, ["content"]);
      instance.setProps(deepPreserveProps(instance.props, Object.assign({}, props, {
        overrides
      })));
      instance.setInstances(children.map(function(child) {
        return child.instance;
      }));
      if (disabled) {
        instance.disable();
      } else {
        instance.enable();
      }
    });
    return (0, import_react.useMemo)(function() {
      var source = {
        data: mutableBox,
        hook: /* @__PURE__ */ __name(function hook(data) {
          mutableBox.sourceData = data;
        }, "hook"),
        cleanup: /* @__PURE__ */ __name(function cleanup() {
          mutableBox.sourceData = null;
        }, "cleanup")
      };
      var target = {
        hook: /* @__PURE__ */ __name(function hook(data) {
          if (!mutableBox.children.find(function(_ref3) {
            var instance = _ref3.instance;
            return data.instance === instance;
          })) {
            mutableBox.children.push(data);
            if (mutableBox.instance && !mutableBox.instance.state.isDestroyed) {
              mutableBox.instance.setInstances(mutableBox.children.map(function(child) {
                return child.instance;
              }));
            }
          }
        }, "hook"),
        cleanup: /* @__PURE__ */ __name(function cleanup(instance) {
          mutableBox.children = mutableBox.children.filter(function(data) {
            return data.instance !== instance;
          });
          if (mutableBox.instance && !mutableBox.instance.state.isDestroyed) {
            mutableBox.instance.setInstances(mutableBox.children.map(function(child) {
              return child.instance;
            }));
          }
        }, "cleanup")
      };
      return [source, target];
    }, []);
  }, "useSingleton");
}
__name(useSingletonGenerator, "useSingletonGenerator");
var forwardRef = /* @__PURE__ */ __name(function(Tippy, defaultProps2) {
  return (0, import_react.forwardRef)(/* @__PURE__ */ __name(function TippyWrapper(_ref, _ref2) {
    var children = _ref.children, props = _objectWithoutPropertiesLoose(_ref, ["children"]);
    return import_react.default.createElement(Tippy, Object.assign({}, defaultProps2, props), children ? (0, import_react.cloneElement)(children, {
      ref: /* @__PURE__ */ __name(function ref(node) {
        preserveRef(_ref2, node);
        preserveRef(children.ref, node);
      }, "ref")
    }) : null);
  }, "TippyWrapper"));
}, "forwardRef");
var useSingleton = useSingletonGenerator(createSingleton);
var headless = forwardRef(TippyGenerator(tippy_headless_esm_default), {
  render: /* @__PURE__ */ __name(function render() {
    return "";
  }, "render")
});
var tippy_react_headless_esm_default = headless;

// dep:@tippyjs_react_headless
var tippyjs_react_headless_default = tippy_react_headless_esm_default;
export {
  tippyjs_react_headless_default as default,
  tippy_headless_esm_default as tippy,
  useSingleton
};
//# sourceMappingURL=@tippyjs_react_headless.js.map
